# Costabeach Owner Coordination Platform – Product Requirements Document

## Overview

Costabeach is a web-based platform for a condominium Homeowners Association (HOA) in Morocco, designed to facilitate communication and coordination among property owners. The platform provides a **private owner portal** for registered condo owners (about 300 users) to access HOA documents, announcements, and interactive features, alongside a **public-facing site** showcasing the property for visitors or prospective buyers. Given Morocco’s linguistic landscape, the platform is built to be multilingual (French and Arabic primarily) to ensure inclusivity. The system architecture follows modern web standards (Next.js App Router) and an **atomic design** approach for UI, ensuring the interface is modular, consistent, and easy to maintain. All sensitive HOA materials and interactions are secured behind user authentication, with role-based access control distinguishing regular owners from committee volunteers and admins. Overall, the goal is to streamline HOA management – from sharing documents and news to conducting votes – while bridging language gaps and offering convenient integrations (like WhatsApp notifications and AI-powered assistance) to keep owners engaged and informed.

## Goals

* **Centralize HOA Information:** Provide owners with a one-stop portal for all condominium documents (meeting minutes, financial reports, legal docs, etc.) and announcements, organized and easy to retrieve. This replaces ad-hoc email chains or paper notices with a reliable repository.
* **Facilitate Owner Engagement:** Introduce features like polls/voting on community decisions, Q\&A support, and discussion to increase participation in HOA matters. Owners should have a voice in decisions (e.g. budget approval, maintenance choices) through simple digital voting.
* **Multilingual Accessibility:** Ensure all content is available in French and Arabic (the primary languages of the community) so that no owner is left out. The UI and content should seamlessly switch between languages, including support for right-to-left display in Arabic. Automatic translations or summaries should be provided for documents not in a user’s preferred language, lowering the barrier to understanding complex or foreign-language documents.
* **Empower “Comité de Suivi” (Volunteer Committee):** Support a special role for committee members who coordinate HOA activities. These users need admin-like capabilities to manage content (upload new documents, post updates), manage owner accounts (approve or invite new owners), and coordinate actions. The platform should enable these volunteers to perform their duties effectively while logging their actions (for transparency) and without exposing full system controls meant for platform administrators.
* **Seamless Communication and Alerts:** Keep owners informed through their preferred channels. In addition to the web portal, important updates should be pushed via integration with WhatsApp – a widely used messaging app in Morocco – to deliver digests of new documents or announcements. Likewise, owners should be able to query information via WhatsApp (using an AI assistant that can answer questions about the HOA documents) for convenience.
* **Use of Proven Technologies:** Leverage mature, open-source or third-party services where possible instead of reinventing the wheel. For example, use reliable components for document storage/display, full-text search, and polling so that the team can focus on HOA-specific logic. All integrations must respect the platform’s localization (i18n) and authentication, ensuring only authorized owners access private information.

## Features

**1. Document Management for HOA Materials:** The platform offers a robust document library for all official HOA materials. Owners can view and download documents categorized by type (e.g. committee reports, management company notices, legal documents, financial statements). Key functionalities include:

* **Upload & Storage:** Authorized users (committee or admins) can upload documents (PDFs, images, etc.) through the portal. Files are stored securely (in an S3 bucket) with metadata captured in the database (filename, size, type, category, etc.). Upload progress feedback is provided to the user. The system automatically records who uploaded the file (author) and when, and it assigns the document a unique ID.
* **Listing & Filtering:** Owners can browse a list of available documents in the portal. Documents are presented with a title, brief description, category, and possibly an icon indicating file type. The UI allows filtering by category (e.g., show only “Legal” documents) and by language, as well as a search bar to search by title/description. (Full-text content search is not yet implemented, see Gaps.) Document lists are paginated or limited, loading more as needed for performance.
* **Viewing & Downloading:** Owners can download documents to their device. Clicking a document triggers a secure download link. Prior to download, the system increments a view counter for tracking engagement. For common document types (like PDF), the platform will incorporate an in-browser **document viewer** so owners can preview files without needing external apps. This viewer will likely use an open-source PDF rendering library (e.g. Mozilla’s PDF.js via a React component) to display PDFs within the portal, supporting zoom and page navigation.
* **Document Details & Versioning:** Each document entry stores metadata including upload date, uploader, file size, and view/download counts. Owners see these details to gauge relevance. If a document is updated or replaced, the committee can upload a new version; the system may keep an audit log entry of changes (the database has an `audit_logs` table for recording actions like document uploads or deletions). Currently, basic audit logging is in place to track actions with timestamp and user ID for transparency.
* **Access Control:** All HOA documents are private by default. The system enforces that only authenticated owners can access them. It uses Supabase’s row-level security (RLS) policies to ensure only *published* documents are queryable by normal users. Unpublished or draft documents (indicated by an `is_published` flag) can be staged by the committee and are only visible to those committee users or admins until publication. Moreover, owners can only delete or modify documents they uploaded (or that they have permissions for) – enforced by policies tying document author ID to the auth user ID. This prevents unauthorized tampering. Admins (service role) can override these restrictions when needed for management tasks.

**2. Multilingual Support (French & Arabic):** The platform is fully internationalized. All user-facing text in the UI, as well as content entries, support both French and Arabic. The default locale is French, but each user can switch language via a language toggle on the site. Key aspects:

* **Localized Routing:** The application uses Next.js internationalized routing. The URL structure includes the locale code as a path prefix (e.g. `/fr/…` or `/ar/…`), and the system will redirect or default to the appropriate locale based on user preference or browser settings. A middleware is implemented to automatically append the default locale to root URLs for convenience.
* **UI Translation:** All static labels, navigation items, and common text are stored in translation files (e.g. JSON or YAML) and loaded via an i18n library (the project is set up to use Next.js i18n and likely `next-intl` or a similar library for managing messages). There’s a central i18n config defining supported locales (currently `'fr'`, `'ar'`, and optionally `'en'` for future). Dynamic content in components is rendered in the active language. The team has built an `I18nProvider` and utility hooks to fetch translations in both client and server components. Right-to-left (RTL) layout for Arabic is handled by adding `dir="rtl"` and appropriate style adjustments – the system ensures components flip their layout appropriately for Arabic. For example, the language switcher dropdown accounts for RTL positioning so it displays correctly in Arabic.
* **Content Localization:** Every piece of user content (documents, information posts) carries a language attribute in the database. Documents can have associated translated versions: the `documents` table has a self-referential link `translated_document_id` to another document entry, indicating an available translation. Similarly, an `information` (announcement) entry has a `language` field and may point to a source or translated copy. This allows storing separate records for each language version of a document or announcement while linking them together. The UI will show if a translated version of a document is available (e.g. “Also available in Arabic”) and allow switching. If a piece of content is only in one language, the platform will offer to translate or summarize it (see next section).
* **Forms & Validation in Multiple Languages:** All user input forms (e.g. contact form, login) provide labels and validation messages in the selected language. The platform ensures that error messages or prompts are translated. For example, the contact page has been tested to include French and Arabic translations for all sections and validation messages. This reduces confusion for non-French speakers and provides a polished localized experience end-to-end.

**3. Document Translation & Summaries (AI Assistance):** To help owners understand documents that might not be in their preferred language (or are too lengthy/complex), the platform will provide **explanatory summaries** and translation on demand. This feature is partly implemented and will be expanded using AI services:

* **On-Demand Document Translation:** Owners can request a translation of a document into another language (French or Arabic). The UI includes a “Translate” action (for example, an Arabic-speaking user viewing a French document can click “Translate to Arabic”). Upon request, the system calls an AI translation service in the background to generate a translated version of the document. The codebase already includes a placeholder for this: there is a tRPC mutation `translations.requestDocumentTranslation` which is invoked when a user requests a translation. The translation workflow likely uses an AI API (OpenAI or other large language model) to produce the content. Once completed, the translated text/PDF is saved as a new document record linked via `translated_document_id` and then becomes available in the UI. The system notifies the user or refreshes the view when the translated version is ready (possibly using a polling mechanism to check translation job status). This ensures that non-French speakers can obtain official documents in Arabic (and vice versa) relatively quickly.
* **Explanatory Summaries:** For lengthy or complex documents (e.g. legal texts or financial reports), the platform will offer an auto-generated summary in the user’s language. Upon opening a document, a summary section will display a short overview in plain language. This will be powered by an AI model that reads the document text and produces key highlights or an explanation. For example, an HOA financial report could be summarized to “Key expenses this quarter and budget variances.” This helps users grasp the essence without reading dozens of pages. The summary can be generated at upload time (and stored in the database) or on-demand when the user clicks “Summarize.” We will integrate with an AI service (OpenAI GPT-4 or similar, via our `aiClient` library) to generate these. Each Document entry may be extended with a `summary` field (storing text in multiple languages, or separate summary records per language) so that committee members can review/edit the summary if needed. Summaries will respect language preferences – e.g., an Arabic summary is provided for an Arabic user even if the document is originally in French.
* **Implementation Notes:** The system’s AI integration layer (`src/lib/aiClient.ts`) is designed to work with multiple providers (OpenAI, Anthropic, Google Gemini, etc.), giving flexibility in choosing the model for translation or summarization. The translation feature is partially completed – the UI and backend calls exist to request and retrieve translated docs – but further work is needed to handle large documents and to store the AI outputs persistently. Summarization is a new addition to be built, ensuring we store summaries and display them in the document preview modal or detail page. Both translations and summaries should be logged (e.g., an entry in `audit_logs` noting that “Document X was translated to Arabic by user Y on date Z”) for traceability.

**4. Polls and Voting:** To promote community engagement, the platform will include a **polling/voting module** where HOA management or the volunteer committee can post questions for owners to vote on. Example use cases include voting on renovation proposals, budget approvals, or gathering opinions on community issues. This feature is not yet implemented, but the requirements are as follows:

* **Create & Manage Polls:** Committee members (or admins) can create a new poll through the portal. A poll consists of a question (e.g. “Should we renovate the lobby this year?”), a description or context, and a set of options for responses (e.g. “Yes/No” or multiple-choice options). The poll creator can set a closing date/time for the vote and whether results are visible before closing. Polls will be stored in a new database table, e.g. `polls`, with fields for question text (in multiple languages), status (open/closed), creator id, creation date, and closing date. Each poll option can be stored as a related table (`poll_options`) or a JSON array in the poll record.
* **Voting Mechanism:** When a poll is open, any verified owner can cast one vote. The UI will present the question and options (localized in the user’s language). Owners select an option and submit their vote. The system records the vote in a `votes` table with the voter’s user ID, the chosen option, and a timestamp. To ensure fairness, each user can only vote once per poll – the backend will enforce uniqueness of (poll\_id, user\_id). Votes are private during the poll; owners cannot see interim results (unless the poll is configured to show a running tally). After the poll closes, results are tallied and displayed.
* **Results Display:** Once a poll’s deadline passes (or if the poll is manually closed by an admin), the results are calculated as percentages and counts of each option. The platform will display the outcome visually, e.g. a bar chart or pie chart for each option’s share. We can integrate an open-source chart library (like Chart.js or Recharts) to present these results graphically, which saves time over building custom charts and ensures compatibility with our framework. The results view should be visible to all owners, and archived polls can remain accessible for transparency.
* **Integration & Permissions:** Only users with appropriate permissions can create or close polls. This will typically include committee members and admins (permission like `managePolls`). Regular owners can only vote, not create polls. Poll creation forms and vote submissions will both respect the platform’s auth (only logged-in owners can participate). Additionally, polls can be tagged or categorized (perhaps by topic), and like documents, they should support multilingual content – the poll question and options should be entered in both languages so that, for example, an Arabic user sees the question in Arabic. If needed, the platform could assist by translating poll content for the other language using the AI services. Poll data will be associated with the `audit_logs` (e.g., “User X created poll Y” or “User Z voted in poll Y”) for record-keeping.

**5. WhatsApp Integration (Linking & Digest Alerts):** Many owners rely on WhatsApp for day-to-day communications. To meet users where they are, Costabeach will integrate with WhatsApp in two ways: linking accounts for verification, and sending digest messages with important updates.

* **Account Linking via Phone Number:** During registration or in their profile, users can provide their phone number (which is stored in the `users` table). The platform will use this number to link the user with WhatsApp. A one-time verification (such as sending a code via WhatsApp or SMS) may be implemented to ensure the number is correct and the user consents to WhatsApp communications. Once verified, a user’s profile is marked as WhatsApp-linked. This allows the system to confidently send them messages.
* **Digest Notifications:** The platform will periodically send out WhatsApp messages to owners to highlight new content. For example, a **weekly digest** might list new documents uploaded that week, recent announcements, or an active poll that needs their vote. These messages will be generated by the system (in the user’s preferred language where possible) and sent via the WhatsApp Business API (using a service like Twilio or the WhatsApp Cloud API). Each message will include brief titles or summaries and a link to the portal (since all content is private, the link will direct to the login or use a deep link with a token to authenticate). The digest frequency and content can be configured by the committee – e.g., immediate alerts for urgent notices, vs. weekly roundups for general updates.
* **Two-Way Linking:** The WhatsApp integration will also allow an owner to click on a link in the WhatsApp message and be taken directly to the corresponding content in the web portal (after logging in). This provides a smooth bridge between the notification and the web app. In future iterations, we may allow simple interactions via WhatsApp, e.g. replying with “Yes” or “No” to cast a vote in a poll, which would require parsing incoming messages – but initially, the focus is on outbound communications (digests and alerts).
* **Privacy & Opt-Out:** Owners will explicitly opt in to WhatsApp notifications during onboarding (since not everyone may want HOA messages on their phone). The platform will store a flag or use the phone verification status to determine opt-in. All WhatsApp communications will adhere to messaging policies (only relevant HOA content, reasonable frequency). If an owner opts out, the system stops sending to that number.
* **Technical Implementation:** We will integrate a WhatsApp messaging service via API. Open-source libraries or SDKs provided by WhatsApp/Twilio will handle the lower-level details. We will ensure localization by sending messages in the user’s preferred language (our system can template the digest message in multiple languages). Authentication integration is minimal for outbound messages, but for links we might implement special one-time tokens in URLs or instruct users to log in. Since phone numbers are stored in the database and tied to user IDs, we can match incoming webhooks (for replies, if enabled) back to user accounts. Initial integration will focus on sending digests reliably. Logging will be added for each WhatsApp message sent (to an audit log or messaging log table) for accountability (who was sent what, and if delivery was successful).

**6. WhatsApp Q\&A Assistant (Document Understanding Agent):** In addition to static digests, the platform will provide an interactive Q\&A chatbot accessible through WhatsApp. This AI-driven assistant will allow owners to ask questions about HOA documents or policies in natural language and receive helpful answers drawn from the stored information. For example, an owner might message the WhatsApp bot, “What was the budget decided in the last AGM?” and the assistant would respond with the relevant figure or summary from the meeting minutes. Key points:

* **AI Knowledge Base:** The assistant’s intelligence comes from the HOA’s documents and possibly an internal knowledge base. We will index the content of uploaded documents and important information posts so that the AI can search and reason over them. This likely involves using an embedding-based search (vector database) or a specialized Q\&A service. We might use an open-source framework like **Haystack** or **LangChain** with our own data, or leverage an AI service with retrieval capability (OpenAI with embeddings, or a service like Perplexity as suggested by the `PERPLEXITY_API_KEY` in the config). The content needs to be kept up-to-date whenever new documents are added.
* **User Interaction via WhatsApp:** Owners will interact simply by messaging the HOA’s WhatsApp number. The system (via a webhook integration) will receive the question, pass it to the AI Q\&A module, and then return the answer as a WhatsApp message. For example, user asks a question in French; the bot finds the answer (perhaps from an English document) and responds in French, citing the document name or date for reference. The assistant will support both French and Arabic questions and answers, translating on the fly as needed.
* **Document Safeguards:** The assistant will only answer questions with information that an authenticated owner is allowed to see. Because all data is private, we must ensure that the Q\&A pipeline checks the user’s identity (the WhatsApp message will come from a verified number linked to a user) and uses *only the documents that user has access to*. Since all owners have access to published documents, the main concern is to restrict any unpublished or admin-only content. We will maintain the permission logic by indexing only published/owner-accessible content for the assistant. Additionally, every answer can include a reference (e.g. “according to the Minutes of Meeting on 2025-01-10”) to maintain transparency.
* **Technology Integration:** We will build on our existing AI integration. The platform’s `aiClient` can route queries to the appropriate model. For Q\&A, we might integrate a combination of an embedding search (to retrieve relevant document text) and a large language model to formulate the answer. Open-source components like **Milvus or Pinecone** (for vector storage) and **Haystack** (for QA pipelines) could be used so we can host the solution and control localization. If an open-source model (e.g., a smaller LLM or a local Arabic-friendly model) is feasible, we will consider it; otherwise, we’ll use OpenAI GPT-4 or similar via API, with the necessary prompts to incorporate our data. The key is that any external integration must handle French/Arabic well (OpenAI does, but we’ll verify quality for Arabic responses).
* **User Experience:** The WhatsApp Q\&A should feel like chatting with a knowledgeable assistant. It will be always accessible. We will program some system prompts to ensure the AI remains factual (perhaps even quoting from text) and avoid speculation. If an answer cannot be found, it should politely say it doesn’t have that info, rather than hallucinate. This feature greatly increases accessibility – owners who find the portal cumbersome can simply ask a question on WhatsApp and get an immediate answer, making HOA info retrieval as easy as texting a friend.

## Existing Implementation (Current State)

The Costabeach platform is built on a strong foundation, with many core pieces already implemented in the codebase. Below is a summary of the current implementation, including functionality, architecture, and data schema, as reflected in the repository:

* **Architecture & Tech Stack:** The application is built with **Next.js 14** (using the App Router) and **TypeScript**, ensuring a scalable, modern front-end. It follows an App Directory structure (e.g. `app/page.tsx` as the root) and uses React server components where appropriate. The project integrates **Supabase** as the primary backend – this serves a PostgreSQL database (for data storage) and also leverages Supabase Auth for user authentication and Row Level Security. The codebase also includes **Prisma** as an ORM layer for managing the database schema and running migrations. For authentication, the initial template included NextAuth, but the implementation has shifted to use **Supabase Auth with Clerk integration** on the front-end. Specifically, Clerk is intended for front-end components (nice UI for sign-in, etc.), while Supabase handles the actual auth state and persistence in the database. In practice, the team has stubbed Clerk components (for example, a placeholder SignIn component), and the logic for signing up/in is handled via Supabase’s JS client (email and password credentials). This hybrid approach means the platform can use Clerk’s drop-in UI widgets but still unify user accounts with the Supabase database for authorization rules.
* **Atomic Design System & UI:** The front-end is organized according to **Atomic Design principles**. The repository is structured into directories for Atoms, Molecules, Organisms, Templates, and Pages. For example, there are atom components like `Button`, `Input`, `Heading`, `Paragraph`, molecules like `Form` and `Card`, organisms like `Header`, `Footer`, `OwnerPortalSidebar`, `DocumentList`, template layouts for pages, and then actual page implementations. This system is largely in place – the task list in the repo shows all atomic components through pages have been built and have Storybook stories. The **Storybook** is set up (with some remaining configuration tasks pending) to allow isolated development and documentation of UI components. The public-facing pages (Home, Property Detail, Contact) are implemented using the Public template (with hero images, property info, contact form). The private pages (Owner Login, Owner Dashboard) are also implemented: the Owner dashboard uses a template that combines the sidebar menu and the document list area. Overall, the UI work for the MVP is mostly complete, pending refinements in styling and theming (e.g., a global theming provider for consistent colors and dark mode is planned but not done). The app is responsive and uses **Tailwind CSS** for styling utility classes (Tailwind is included in the stack for rapid UI development). Icons are provided via the Lucide icon set.
* **Internationalization:** The project has internationalization configured. In code, there is a `lib/i18n` module with config for locales (French, Arabic, English) and utilities for server and client translation loading. Next.js middleware is active to handle locale redirects (as described earlier, it prepends `/fr` etc. to paths and checks cookies). The UI components and pages have been refactored to use a shared translation approach (e.g., possibly a `useI18n` hook) – although some translation integration tasks were pending, most critical pieces for i18n are done (the dev plan shows i18n setup and language switcher as completed). Right now, the app defaults to French and supports toggling to Arabic; English is configured but may not have full content translated yet (it might be intended for future or for developer testing). All form labels and static text have entries in translation files (the repository indicates creation of translation JSON/YAML files and a strategy to organize them by feature). Further refactoring may be ongoing to ensure every hardcoded string is replaced with a lookup, but the framework is present. Importantly, the system is mindful of RTL layout for Arabic – global CSS and component styles have been tested for Arabic display (ensuring proper alignment).
* **Authentication & User Management:** Currently, user authentication is handled via Supabase. The app uses Supabase’s email/password sign-up and sign-in flows: there are functions like `signUp(email, password, userData)` and `signIn(email, password)` in the code, which call `supabase.auth` APIs. On sign-up, the code passes additional metadata (name, building number, apartment, phone, etc.) so that those get stored in the Supabase auth user’s metadata. These trigger a database function to create a profile in the `users` table (via Supabase triggers) – effectively linking the auth user ID to an entry in our `users` table with all the extra fields. The “Owner Login” page is implemented and integrated with Clerk’s UI; however, the underlying auth state is managed by Supabase (session cookies and JWT). Once logged in, Next.js middleware and hooks ensure only authorized pages are accessible. The app sets an `AuthWrapper` component that checks authentication status on client side and redirects to sign-in if not logged in. New user registration is moderated: the database has an `owner_registrations` table to collect sign-ups that need approval. The workflow is likely that when an owner first signs up, their account is created with a `pending` status in that table, and an admin or committee member must mark it `approved` before the user gets full access. Additionally, an `allowlist` table exists containing pre-approved email addresses – meaning the HOA can restrict sign-ups to known owners only. If implemented, the sign-up process can check the email against this allowlist (and possibly auto-approve the registration if it matches). The repository contains API routes (e.g., `/api/users/ensure-user-exists`) that handle synchronizing user records and possibly adding new users to the allowlist or users table if they don’t exist. There is also a `/api/setup-user` route which, given an email, will ensure a corresponding user profile is created and assign that user an “owner” role with default permissions. This suggests the onboarding flow and data seeding for existing owners is largely built.
* **Roles & Permissions (Comité de Suivi and Admin):** The concept of roles is present in the system. The `users` table has a `role` field (enum) and a `permissions` array field. The enum currently includes values: “user”, “admin”, and “contentEditor”. In practice, **“user” corresponds to a regular owner**, **“contentEditor” would be the Comité de Suivi volunteer**, and **“admin”** for a super-admin. There is also a boolean `is_admin` flag (perhaps redundant with role=admin) for quick checks. The system assigns default permissions based on role: for instance, when an owner is fully set up, the code gives them permissions like `["viewDocuments", "downloadDocuments", "requestTranslations"]`. A contentEditor (committee) would get a broader set, like `manageDocuments`, `manageUsers`, `approveRegistrations`, etc., as indicated in the development notes. Admin would effectively have all permissions (possibly indicated by `is_admin=true` or by role plus an open permissions array). These roles are not yet fully exploited in the UI (since features like user management and content approval are still being built), but the backend policies are prepared. For example, the middleware checks if a user accessing `/owner-dashboard` is a verified owner – if not, they are redirected away. Similarly, admin pages would check for admin role. The database RLS policies also take roles into account: a policy allows the Supabase service role (used by server processes with admin privileges) to bypass RLS for managing all users. In summary, the framework for roles is **in place** – users have roles and permission sets defined – but the application still needs to implement the interfaces and enforcement for many admin capabilities (see Gaps section).
* **HOA Content Management:** Aside from documents, the platform is set to handle general informational content such as news updates or notices. The `information` table in the database is designed for this purpose. It stores an info item’s title, content (text), category (likely using the same categories enum as documents, e.g., legal, general, etc.), language, and an author reference. This is useful for posting things like “Announcement: Pool maintenance next Thursday” or “Summary of board meeting decisions” in text form. Currently, the UI for such posts (perhaps a news feed or bulletin board in the owner portal) is not yet implemented, but the data model exists. We anticipate a section on the owner dashboard where these information posts appear chronologically. Committee members would be able to add these updates from an admin interface. This content will also be subject to multilingual requirements: either each post is written separately in FR and AR, or the system uses AI to translate them for the other language. In the interim, the committee might create two entries (one for each language) and link them via a “translated\_from” field (the `information` table has a `translated_from` text field which could hold an ID or reference).
* **Existing Document Management Implementation:** The core of document handling is operational in the current code. There is a React `DocumentList` organism component that fetches documents (via a custom hook calling our tRPC API) and supports filtering by category and language. Documents are displayed using a `DocumentCard` component, which shows the document title, an icon (based on file type), and actions like view/download, delete (if user has rights), and request translation. The document download flow is fully implemented: clicking download triggers a secure URL fetch (`getDownloadUrl` tRPC call) and then automatically starts the file download for the user. The upload flow is also implemented: when an authorized user selects a file to upload and enters metadata, the `uploadDocument` function obtains a signed S3 upload URL from the backend (`getUploadUrl` tRPC mutation) and then performs the file upload directly to S3. Once uploaded, presumably the backend stores the document record in the database. The UI shows a progress bar during upload. Deletion of documents is implemented via a `deleteDocument` mutation – after a user with permission deletes a file, the UI removes it and invalidates the list cache. The current implementation tracks view counts and download counts per document (incrementing view count on each download action as a proxy for “viewed”; the schema has separate `view_count` and `download_count` fields). These metrics can be used in future to show popular documents or to ensure key documents are being read.
* **What’s Completed vs. Missing:** In summary, the groundwork is laid: we have a working site with authentication, a multilingual interface, and the ability for owners to log in and retrieve documents in a structured way. The static public site is done, and the private dashboard framework is in place (sidebar, document list, etc.). The data model covers users (with roles and metadata), documents and info posts (with multi-language and categorization support), and basic workflow tables (registrations, allowlist, audit logs). **Completed features** include the design system, basic navigation, content fetching from the database, and the document upload/download lifecycle. **Partially implemented features** include internationalization (the structure is ready, translations need to be fleshed out), the user onboarding flow (accounts can be created, but the approval process UI is not built out yet), and document translation (hooks exist to request translations, but full AI integration and UI feedback loop may be pending). **Missing features** (to be developed) include: the document viewer for in-app reading, the polls/voting module, WhatsApp integration (none of this is in place yet), the AI summary/Q\&A features, and the admin interfaces for managing users and content (the committee currently cannot, via UI, approve a pending registration or edit another user’s role – those controls need to be added). These gaps, along with needed data schema updates, are detailed in the next section.

## Gaps & Required Enhancements

To fulfill the product vision, the following gaps in functionality and data need to be addressed:

* **Document Viewing & Search:** *Gap:* Owners currently must download PDFs to read them; there is no in-browser viewing or full-text search. *Task:* Integrate a document viewer (e.g., PDF.js-based) so PDFs and images can be viewed within the app. Implement document text extraction and indexing for search. For example, when a PDF is uploaded, extract its text content (perhaps via an API or library) and store it in a search index (could use Postgres full-text search or an open-source search engine like **MeiliSearch**). Provide a search bar that queries document contents so owners can find documents by keywords (e.g. search all minutes for “budget”). Ensure search results respect permissions and localization (show titles in the UI language, etc.). If full indexing is too complex initially, at least implement improved filtering and maybe file name search on the backend.

* **Explanatory Summaries (AI) Integration:** *Gap:* No current mechanism to generate or display summaries of documents. *Task:* Use the existing AI integration capabilities to implement a summary generator. On document upload (or on first view), call an AI service with the document text to produce a concise summary in French and Arabic. Store these summaries (new fields or table). Update the document detail view to show a “Summary” section. Allow committee editors to edit the summary if needed (to fix any AI inaccuracies before other owners see it). This requires careful prompt design and possibly limiting summary length. Also, include a note that the summary is auto-generated for transparency. The AI costs should be considered (maybe summarize only important categories of documents, or allow on-demand summary by user request to control usage).

* **Document Translation Workflow Completion:** *Gap:* The code to request and retrieve translations exists in part, but the end-to-end flow may not be finished or tested. *Task:* Finalize the translation service integration. This includes deploying a background worker or on-demand function that takes a document (especially PDF) and either translates text within it or produces a translated summary if full translation is not feasible. If full translation is done, consider output format (perhaps generating a PDF with translated text mirrored, or a text version). Ensure the UI clearly indicates when a translation is “In progress” vs “Ready”. Possibly use a notification or email to alert the user when their requested translation is available. Also, add an interface for committee/admin to see all pending translation requests (in case manual intervention is needed). Test with various document lengths to ensure reliability. If AI translation proves inaccurate for formal documents, consider having the committee upload official translations and simply use the linking feature, as an interim solution.

* **Polls/Voting Feature Implementation:** *Gap:* No polls feature exists yet (and no schema for it). *Task:* Design and implement the polling system. Create new tables: e.g., `polls` (poll\_id, question\_text\_fr, question\_text\_ar, created\_by, created\_at, closes\_at, etc.), `poll_options` (option\_id, poll\_id, option\_text\_fr, option\_text\_ar), and `votes` (vote\_id, poll\_id, user\_id, option\_id). Implement pages/UI for: creating a poll (form for question and options in both languages, plus settings like deadline), listing active polls (on the owner dashboard or a dedicated “Polls” page), voting on a poll (with appropriate confirmation and preventing multiple votes), and viewing results (once closed). Use open-source components for the UI where possible: for example, a pre-built poll vote component or chart for results. Ensure real-time or near-real-time updates – when a user votes, reflect it (perhaps via re-fetch or using Supabase’s realtime if enabled on the votes table for live count updates). Also integrate permissions: only committee can create/close polls; all verified owners can vote; admins can oversee all polls.

* **User Management & “Comité de Suivi” Admin UI:** *Gap:* While roles/permissions exist in the backend, there is no front-end UI for managing users (e.g., approving registrations, elevating roles, etc.). *Task:* Build an admin interface (accessible to admins and/or contentEditor roles) for user management. This should include an “Owner Management” page listing all user accounts with their status (pending/approved), roles, and basic info (name, building/apartment). From here, a committee member should be able to approve or reject pending registrations (which updates the `owner_registrations` status and possibly sends an email notification to the user). They should also be able to invite new owners – perhaps by entering an email which adds to the allowlist and triggers an invite email via Resend. Additionally, allow viewing/editing a user’s role (e.g., promote a user to contentEditor if they join the committee, or demote if needed). Changes to roles or approvals should be logged (audit log). Because the platform might limit who can be an admin vs. contentEditor, it might be that only an existing admin can grant someone the admin role, whereas committee (contentEditor) could be managed more freely. We should enforce that logic in the UI (e.g., committee cannot make someone else an admin). This interface greatly empowers the “comité de suivi” to keep the user base accurate (especially as property owners change over time).

* **WhatsApp Integration for Notifications:** *Gap:* No integration with WhatsApp currently; phone data is collected but not used. *Task:* Implement the WhatsApp outbound messaging service. We will likely use a cloud function or scheduled job (perhaps using a tool like Inngest or Supabase cron) to send out weekly digests. This involves writing a script that queries recent content (e.g., documents uploaded in the last 7 days, open polls, upcoming events) and formatting a WhatsApp message. Integrate with Twilio’s WhatsApp API (or an equivalent) using stored API credentials. This requires an initial configuration of WhatsApp Business and obtaining approval for message templates (WhatsApp has policies for proactive messaging). Ensure that each message sent is tailored to the user’s language preference. Also, provide an opt-out mechanism: e.g., instruct users to reply “STOP” to unsubscribe, and handle that by marking a field in their profile to exclude them from future sends. (Inbound handling of “STOP” can be done via a webhook from Twilio). Before sending real messages, we should test thoroughly with a small group. Also, include in the user profile UI a toggle for “WhatsApp Notifications” so users can manually opt out/in. All these require back-end logic and some front-end settings page updates.

* **WhatsApp Q\&A Chatbot Development:** *Gap:* No chatbot/assistant exists yet. *Task:* Develop the Q\&A agent and connect it to WhatsApp. This is a complex feature requiring multiple components: set up a vector database or use an existing Q\&A service, index the HOA documents, and create a query pipeline. We might start by using OpenAI’s embeddings: upon each document upload, compute embeddings for chunks of the text and store them in a Postgres table or an external vector store. When a question comes in, use the phone number to identify the user and verify they have access, then retrieve relevant text chunks via similarity search, then feed those plus the question to an LLM to get an answer. The result is sent back via the WhatsApp API. We need to implement a server (Node or serverless function) to handle incoming WhatsApp webhooks (Twilio will send an HTTP request for each incoming message). This handler will call our QA logic and respond. We must ensure it’s robust against tricky questions and that it does not leak any info not in documents. Possibly integrate open-source QA frameworks to accelerate development (Haystack provides a pipeline we could adapt, including support for multilingual question/answer). Because this is a new domain for the team, we should phase it: first get a basic Q\&A working on a small set of data, then expand. Also, the chatbot should have some understanding of common questions (maybe an FAQ mode for things like “how do I pay my fees?” if that’s not in documents explicitly). Logging is important – we should log each question asked and the answer given (maybe in a “chatbot\_logs” table) so that the committee can review for accuracy and see what owners are asking. This can inform if additional documents or clarifications are needed on the portal.

* **Performance and Miscellaneous:** As we add features, we need to keep an eye on performance. Some tasks here: optimize the initial loading of the dashboard (perhaps use lazy loading for document lists or polls), ensure Storybook docs are updated for any new components (like Poll components or admin UIs), and finalize theming (a consistent color scheme matching Costabeach branding). Also, implement any remaining error boundaries or 404 pages for better UX. Finally, once all features are in, thorough testing (unit, integration, and user acceptance testing) will be needed to ensure stability.

Each of these tasks ties back to the product requirements and will bring the platform to parity with the vision. Prioritization is suggested in the Roadmap below.

## Data Schema Updates & Considerations

The current database schema (managed via Prisma and Supabase) already covers many entities, but a few additions and modifications are needed to support the remaining features. Below is an outline of the schema as-is and the proposed updates:

* **Users:** The `users` table (in the public schema) holds profile info for each user/owner. Key fields include `id` (UUID from Supabase Auth), `name`, `email`, `building_number`, `apartment_number`, `phone_number`, `preferred_language` (enum of Language), `role` (enum UserRole) and `permissions` (text array), plus flags like `is_verified_owner` and `is_admin`. This table is synced with Supabase Auth’s internal user table via triggers – whenever a new auth user is created, a profile is inserted with default role 'user'. **Gaps:** We should verify that the `role` enum includes all needed roles. Currently it has 'user', 'admin', 'contentEditor', but in code we see usage of 'owner' as a role string which is not in the enum (likely 'owner' was meant to map to 'user'). To avoid confusion, we might update the enum to include 'owner' or consistently use 'user' for owners. It might be simplest to consider 'user' == owner and not add a new value. The `permissions` array allows fine-grained rights (e.g., \['manageDocuments', ...]). We should define and document what each permission string means. For example: **manageUsers** (can invite/approve owners), **manageDocuments** (upload/delete any document), **manageComiteDocuments** (manage docs categorized under comité de suivi?), **approveRegistrations**, **managePolls**, etc.. These permission checks will be implemented in application logic (not heavy-lifting in RLS except some broad policies). No new table is needed for roles since the enum and permissions cover it, but we will update the application to use these fields. We should also enforce that at most one of `is_admin` or `role=admin` needs to exist (one is redundant). Likely we rely on `role` and could drop `is_admin` usage.

* **Owner Registrations & Allowlist:** The schema includes `owner_registrations` to track people who have submitted their details to join. Fields: name, email, building\_number, etc., plus a `status` (pending/approved/rejected). This is used for an approval workflow. The `allowlist` table simply stores emails that are pre-authorized. Both are in place. We might consider linking them: e.g., when an allowlisted email signs up, create a registration entry automatically. One schema addition could be a foreign key from registrations to the user (once created) or to allowlist, but it may be unnecessary. Current usage might be: allowlist is checked at sign-up, then registration is created. We should add an index or unique constraint on `owner_registrations.email` (to avoid duplicates; it appears `email` is marked unique in the table definition – indeed it’s unique). No further changes needed here beyond ensuring the application updates the status and maybe adding a `notes` field (already present, for committee to leave a note like “documents submitted verified”).

* **Documents:** The `documents` table is central to HOA materials. Fields include: `id` (UUID), `title`, `description`, `file_path` (probably the key in the S3 bucket), `file_size`, `file_type`, `category` (enum DocumentCategory), `language` (enum Language), flags like `is_published` (default true), counts for views/downloads, timestamps, and `author_id` referencing users. There is also `translated_document_id` which self-references another document ID for translations. The existing schema is well-designed for multi-language support and basic document metadata. **Proposed updates:** We may add a `summary` field (TEXT) to this table to store an auto-generated summary in the original language. However, since summaries are language-specific, another approach is to create a `document_summaries` table keyed by document\_id and language, storing summary text. Alternatively, we piggy-back on the `information` table for summaries (less ideal). A separate `document_summaries` might be cleanest (fields: document\_id, language, summary\_text, maybe last\_updated). This avoids null fields in `documents`. For tracking translations: the `translated_document_id` is already there; we will use it by creating a new document record for the translated file. That is fine. We should double-check the DocumentCategory enum – it includes values like 'comiteDeSuivi', 'societeDeGestion', 'legal', 'financial', 'general', etc., and oddly duplicates in uppercase. This might be a typo in the migration where both uppercase and lowercase are present. We should clean that up to a definitive set (perhaps 'comiteDeSuivi', 'societeDeGestion', 'legal', 'financial', 'general'). Those categories help filter docs and also might control permissions (e.g., maybe only contentEditor can upload 'comiteDeSuivi' docs, only admin can upload 'societeDeGestion' docs – we can enforce that via the app or RLS as needed). The documents table as is can support the needed features once we add summary storage.

* **Information (Announcements/News):** The `information` table (like a “posts” table) has: `id`, `title`, `content` (text), `category` (reusing DocumentCategory enum likely), `language`, an optional `translated_from` (text) to link translations, view count, publish flag, timestamps, and author\_id. This is suitable for multi-lingual announcements. We might refine the `translated_from` to be a UUID reference to another information entry (similar approach as documents) rather than a text field. It currently is a TEXT, which could hold an ID or just some note. A better design: `translated_info_id UUID REFERENCES information(id)`. We should implement that if linking posts. However, if content editors will manually create two versions, they might not need a link. Still, having it helps navigate between languages for the same announcement. This table can be used for meeting summaries, general notices, etc. No major changes needed aside from possibly that reference field type. We will also ensure that creating an information entry auto-generates a translation entry via AI if one isn’t provided (but that can be at application level).

* **Polls and Votes:** *New Tables:* We will introduce two (or three) tables for polling. **polls**: columns might include `id UUID PK`, `question_text_fr TEXT`, `question_text_ar TEXT` (or we store the question in one language and rely on a translations table – but simplest is just have two text fields), `details_text_fr`, `details_text_ar` for any longer description/context, `status` (enum: open, closed, maybe draft), `created_at`, `created_by` (FK to users), `close_at` timestamp, etc. **poll\_options**: `id UUID PK`, `poll_id` FK, `option_text_fr`, `option_text_ar`, maybe an `order` integer for display ordering. **votes**: `id UUID PK`, `poll_id` FK, `user_id` FK, `option_id` FK, `voted_at` timestamp. Add a unique index on (poll\_id, user\_id) in votes to enforce one vote per user per poll. We’ll also likely add an index on poll\_id on votes for counting quickly. We should also consider if we need to record abstentions (probably not explicitly; if user doesn’t vote, no entry). These tables will be managed through Supabase (we can write migrations for them). With RLS: likely all owners can select polls and options (so a policy like “owners can read polls when status = open or closed”), and insertion of votes restricted to the user themself (policy: can insert a vote where user\_id = auth.uid() and only if that poll is open). Committee members can insert polls and options (policy or just do it via admin privileges), and maybe delete or update polls (if editing a poll’s text or closing early – though closing could just be updating status). We might not allow deleting polls once votes exist for record integrity.

* **WhatsApp & Messaging:** We might not need a new table for WhatsApp messages, but it could be useful to log communications. Perhaps a `notifications` table: `id, user_id, type (whatsapp/email), content, sent_at, status`. Or simply rely on external logs (Twilio provides delivery status callbacks). This is optional. For Q\&A, if we want to store chat history, a `qa_sessions` and `qa_messages` tables could be introduced, but not strictly required for functionality. Since the Q\&A is more of a service, we could skip DB storage except for maybe caching answers. One data addition: ensure the `phone_number` field in users is indexed and unique where applicable (we likely want unique phone per user to avoid confusion, though families might share a number – up to product decision). Possibly add a `whatsapp_opt_in BOOLEAN` to users to track consent; or reuse `permissions` (but better a dedicated field).

* **Audit Logs:** The `audit_logs` table exists with a generic structure (action, entity\_type, entity\_id, user\_id, details JSON, timestamp). We should use this to record major events (document uploads, deletions, user role changes, poll creations, etc.). No schema change needed, just ensure our code writes to it as needed. We might extend the `details` JSON structure for certain actions (like for a poll creation, store the question in details for quick reference).

* **Relationships and Foreign Keys:** We should add missing foreign key constraints where appropriate for data integrity. E.g., ensure `documents.author_id → users.id` is a foreign key (likely already is), ensure `information.author_id → users.id` (present), and for new tables: `polls.created_by → users.id`, `poll_options.poll_id → polls.id`, `votes.poll_id → polls.id`, `votes.user_id → users.id`, `votes.option_id → poll_options.id`. Similarly, if we add `translated_document_id`, it should reference `documents(id)` which it does. If we change `translated_from` in information to a UUID, make it reference `information(id)`. These constraints prevent orphaned references and will be reflected in Prisma schema for migrations.

* **Data Volume and Indexing:** Given \~300 users and potentially hundreds of documents, the data volume is manageable. We should index some fields for performance: e.g., `documents(category)`, `documents(language)`, `documents(author_id)` for common queries; `information(category)` if filtering news; and definitely indexes on foreign keys for joins. Supabase by default indexes primary keys and unique constraints. We might also create a full-text index on document content if we store that for search (alternatively, use a separate search service).

In conclusion, the existing schema is robust and requires only targeted additions for new features (polls) and perhaps slight adjustments for linking translations and tracking notifications. These changes will ensure the database can support the full feature set while maintaining data integrity and performance. All new schema elements will be implemented via Prisma migrations and applied to Supabase (with careful use of the provided migration scripts and Supabase’s role-based security to protect the data).

## Roles and Permissions

The platform defines several user roles, each with different permissions and responsibilities. Here we detail the roles, aligning them with the HOA context and what each can do in the system:

* **Owner (Regular User):** This is the default role for anyone who is a verified condo owner. Owners can log into the private portal and have access to all **published** HOA content. Their permissions include viewing and downloading documents, viewing announcements, and participating in polls. They can also request translations of documents and utilize the WhatsApp Q\&A bot for information. Owners **cannot** upload or delete documents (except possibly ones they personally contributed, though by policy they typically won’t contribute official docs), cannot see unpublished drafts, and cannot manage other users. In the database, these users have `role = 'user'` (or 'owner') and a permissions array such as `['viewDocuments','downloadDocuments','requestTranslations']` assigned by default. They are essentially read-only consumers of content (plus interactive features like voting and Q\&A).

* **Comité de Suivi (Content Editor role):** The “comité de suivi” is a volunteer committee of owners who take on coordination tasks. In the system, these users have elevated privileges akin to content managers or moderators. Their `role` is stored as `'contentEditor'`. By virtue of this role, they gain additional permissions, likely including: **manageDocuments** (they can upload new documents and update or remove documents, ensuring the repository stays current), **manageInformation** (post announcements/information updates), **approveRegistrations** (review and approve/reject new owner sign-ups), **manageUsers** (edit basic user info or invite users), and **managePolls** (create polls and view the results dashboard). They may also have category-specific permissions like `manageComiteDocuments` or `manageLegalDocuments` if we choose to differentiate who can manage certain document categories – for simplicity, we can assume all content editors can manage all document categories unless segregating duties becomes necessary. Comité members essentially act as **community admins**, handling day-to-day admin tasks for the HOA content. However, they are not full system admins: they cannot modify system settings, and by policy they shouldn’t change other users’ roles to admin or contentEditor (except possibly adding another owner to the committee role with consensus). In practice, the first contentEditors will be set by an actual admin (the developer or HOA board leader). The UI will reflect these extra powers: contentEditors will see an “Admin Panel” or extra buttons (like “Upload Document”, “Manage Owners”, “New Poll”) that regular owners do not. All their actions should be logged (audit log) to maintain trust. This role is critical – it decentralizes management so that volunteers can maintain the platform content without needing IT support.

* **Administrator (Admin role):** Admin is the super-user role, intended for the HOA’s top-level administrators or the platform maintainer. In many cases, this might be a member of the property management company or the developer of the platform. Admins have **all permissions** – they can do everything contentEditors can, plus more: e.g., manage system configurations, oversee all data, assign roles to others (make someone a contentEditor or even an admin), and access any content regardless of status. There may only be a small number of admin accounts (perhaps one). In the database, `role = 'admin'` and `is_admin = true` for these accounts. RLS policies often exclude them by requiring `auth.role = 'service_role'` for backend service operations, but for front-end, we’ll simply treat them as having every permission. Admins can use the Supabase service key in certain API routes to bypass RLS when needed (the application’s special admin functions do this under the hood). From a product perspective, admins are there to ensure the system runs smoothly – e.g., if a committee member is struggling, an admin can directly insert or fix data using admin tools, or if there’s a dispute or security issue, the admin can intervene (like locking an account). In HOA terms, this role might be used sparingly; possibly the HOA board president or the property management head has this access. It’s also possible that the “admin” is just the developer for now, and contentEditors handle almost everything day-to-day.

* **Unauthenticated/Public:** While not a “role” stored in the users table, it’s worth noting that public visitors (not logged in) have access only to the public marketing pages of the site (and nothing from the owner portal). Some documents or information might be marked as public (if the HOA decided to share certain rules or news publicly), but by default all HOA materials require login. The public role essentially has no permissions in our system except viewing those explicitly public pages. The middleware ensures that accessing any private route will redirect them to sign-in.

**Role-Based Content Visibility and Actions:** The system uses these roles to control UI elements and route access. Middleware on protected routes checks if the session exists (logged-in) and in the case of owner-specific pages, also checks `is_verified_owner` flag – meaning the user’s registration is approved – otherwise it kicks them out. In the future, we might add checks like “if not admin, redirect from /admin pages”. On the front-end, we’ll conditionally render admin menus for contentEditors and admins. For example, a regular owner sees a read-only Documents list, whereas a comité member sees the same list but with an “Upload Document” button and delete icons on each item. Similarly, owners see polls to vote, but contentEditors see an option to create or close polls. These differences will be implemented by inspecting the `user.role` and `user.permissions` provided (the `AuthUser` object returned by our `getUser()` includes the user’s role and permissions).

**Permissions Implementation:** Instead of hardcoding role names in many places, the app will likely use the `permissions` array to check fine-grained abilities. For instance, a component for uploading documents might do something like: `if (!user.permissions.includes('manageDocuments')) hide upload form`. This way, if down the line we create another role (say a “Manager” role for the property manager separate from comité), we can just assign the appropriate permissions and the UI logic holds. It also means we can toggle specific abilities easily. The development plan listed some of these permission strings and indicates tests were written for permission enforcement. Those tests presumably ensure that, e.g., a user without `manageUsers` cannot call the API to approve a registration, etc. We will continue to expand on that and use Supabase RLS as a second line of defense where feasible (for example, an RLS policy on `documents` could allow `insert` only if `auth.uid()` has a role of contentEditor or admin; currently, the approach is more that unauthorized inserts just wouldn’t be attempted by the app, but adding RLS for critical tables is wise to prevent misuse via direct API calls).

In summary, the roles are: **Owner (basic access), Committee/ContentEditor (content managers), Admin (superuser)**. This structure covers our needs, with permission strings to fine-tune access within those categories. We have implemented the roles in the data model and partially in logic; the next steps will fully utilize them in the UI and backend checks, so that each user sees and can do exactly what their role permits – no more, no less.

## Roadmap (Phased Development Plan)

To reach the full envisioned product, development will proceed in phases. Each phase builds upon the last, incrementally delivering capabilities. Below is the proposed roadmap with phases, the focus of each, and work status:

**Phase 1: Foundation and MVP (✅ Completed)**

> **Focus:** Establish core infrastructure, basic features, and deploy a minimum viable product for initial use.
> **Includes:**
>
> * **Setup Core Stack:** Initialized Next.js app, integrated Supabase (DB and Auth), and Prisma for schema migrations. Established project structure with atomic design system.
> * **Design System & Pages:** Built out Atoms, Molecules, Organisms, Templates, and Pages for both public site and owner portal (Home, About, Contact, Owner Login, Owner Dashboard, etc.). Ensured responsive design and basic accessibility.
> * **Authentication:** Implemented user sign-up and login using Supabase Auth (email/password). Integrated Clerk UI components for a smooth login experience (placeholder components in place). Middleware protects private routes.
> * **Internationalization:** Configured i18n routing and locale detection (French default). Created language switcher and verified UI in French and Arabic (RTL).
> * **Document Management (Basic):** Set up database tables for documents and info. Implemented file uploads to S3 with progress and secure downloads. Owners can view a list of documents with filtering by category/language. Document metadata (title, description, categories) defined and UI integrated.
> * **Roles & Permissions Model:** Established user roles (owner, contentEditor, admin) and permission fields in schema. Assign default permissions on user creation. Enforced basic differences (e.g., restrict non-owners from owner pages).
> * **Testing & Storybook:** (In progress) Set up Storybook environment and wrote stories for core components. Wrote initial unit tests (especially for util functions and permission logic).
>
> **Status:** Phase 1 is largely complete. The MVP allows an owner to log in and download available documents in their chosen language. The public site is live for informational use. Some polishing tasks (e.g., Storybook documentation finalization, theming, etc.) remain but the foundation is stable.

**Phase 2: Enhancing Content Features (🔄 In Progress)**

> **Focus:** Complete the document and content-related features, and implement multilingual content support fully.
> **Includes:**
>
> * **Document Viewing & Search:** Integrate an in-app PDF viewer for documents. Researching PDF.js integration to allow reading PDFs on the page. Implement full-text search for document contents – likely using an open-source search engine (evaluation of MeiliSearch underway). This will allow owners to search within minutes or reports for keywords.
> * **Document Translation:** Finalize AI translation workflow. Connect the `requestDocumentTranslation` backend to an OpenAI function that translates PDFs (possibly by extracting text and translating chunk by chunk). Implement UI indicators for translation status (e.g., a spinner or “Translating...” note). Ensure translated documents get linked and stored properly in the database with `translated_document_id` and correct language field.
> * **Document Summaries:** Build the summary generation feature. Using the OpenAI API (with GPT-4 model), automatically generate summaries for new documents in both languages. Add a summary display in the Document preview modal. Possibly allow committee members to trigger re-generation or edit the summary.
> * **Announcements/Information Module:** Bring the `information` table to life by creating an “Announcements” section on the owner dashboard. ContentEditors can post news updates (with title/content in FR and AR). Owners see a feed of these posts (with automatic filtering to their language, or the ability to toggle language). Use the same translation approach for posts if needed (or require contentEditors to input both translations). This keeps all owners informed of latest news on the portal home.
> * **Localization Completion:** Translate any remaining UI text to Arabic (and English if we decide to support a basic English version for non-local stakeholders). Ensure all validation messages, date formats, etc., localize properly. Conduct a review of the site in Arabic to catch layout or overflow issues.
> * **Performance & Polish:** As content features firm up, optimize loading. Implement lazy loading for document lists and code-splitting for heavy components (like PDF viewer) so they don’t slow initial load. Finish global theming (light/dark mode toggle, consistent colors). Complete Storybook docs for all new components (document viewer, announcement card, etc.).
>
> **Status:** In progress. The team has begun integrating OpenAI for translations (API keys set up, backend stubs in place). Summaries and viewer integration are being prototyped. We expect Phase 2 to complete with a fully content-rich portal where language is no barrier.

**Phase 3: Community Interaction Features (🚧 Upcoming)**

> **Focus:** Introduce interactive features like polls and refine user management for community engagement.
> **Includes:**
>
> * **Polls & Voting:** Implement the polls feature from back to front. This involves database migrations for polls/options/votes, creating the Poll management UI for contentEditors (perhaps under a new “Community” or “Polls” tab in the portal), and the voting interface for owners. Use real-time updates or periodic refresh so that, once a poll closes, owners can immediately see results. Also, add email or WhatsApp notifications for new polls (so owners don’t miss an opportunity to vote). Aim to align the poll closure and result announcement with meetings or deadlines as needed by HOA governance.
> * **User Management Tools:** Develop the “Manage Owners” page for committee/admin. This includes listing pending registrations (with approve/reject buttons) and the ability to resend invite emails. Also incorporate editing of owner info (sometimes typos in emails or name changes need admin fix) – allow contentEditor to update basic fields for a user. Role management: admins can promote/demote roles here. Additionally, consider a feature to mark an owner as no longer active (if they sell their unit, for example) – which could deactivate their login. Such actions might tie into Supabase Auth (maybe disabling the account). For now, a simple solution is contentEditors can remove a user’s `is_verified_owner` or add a “inactive” flag so they can no longer log in, and add a new registration for the new owner of that unit.
> * **Audit Trail & Notifications for Admin Actions:** To complement user management, ensure that critical actions (approving an owner, changing a role, creating a poll) trigger notifications or at least confirmations. For example, when a new owner is approved, the system should send them a welcome email via Resend (since email setup is present). When a poll is created, perhaps notify all owners via email or WhatsApp (if opted in) that “A new poll is open for voting.” These notifications will increase engagement. The groundwork (email server and Resend API) is configured; we just need to implement the email templates and triggers.
> * **Content Organization & Search:** With more content (documents, posts, polls), refine the portal UI for organization. Possibly implement a sidebar or filters for documents (by year or by category). Also consider a global search function on the dashboard that can search across documents and announcements. This might integrate with the earlier search index work.
> * **Mobile Responsiveness & PWA:** Many owners might use mobile devices. Ensure that by Phase 3 the portal is fully usable on mobile browsers. Possibly package it as a Progressive Web App for easier access (so users can “Add to Home Screen”). Test all interactive features (poll voting, document viewing) on common smartphones. If WhatsApp features are heavily used, mobile is critical because they might click from WhatsApp into the site. Smooth out any mobile UX issues (like the sidebar turning into a hamburger menu, etc.).
>
> **Status:** Not started (planned). Phase 3 will start once Phase 2 is near completion. We anticipate prioritizing polls first (so that some community feedback mechanism is available), then user admin tools. This phase will significantly increase user engagement on the platform by giving them avenues to participate and by giving the committee the tools to manage the community digitally.

**Phase 4: Integration & AI Excellence (🚧 Upcoming)**

> **Focus:** Final integrations with external services (WhatsApp) and advanced AI features for a truly smart platform.
> **Includes:**
>
> * **WhatsApp Digest Integration:** Activate the WhatsApp notification system. This involves working with Twilio API (or similar) to send out periodic digests as described. Develop the content of these digests (likely a concise list of highlights, possibly using the summary text for documents). Implement scheduling – possibly using a serverless cron job or using Supabase’s background job capabilities if any. Test sending to a few numbers, ensure formatting is good (WhatsApp messages can support simple formatting like *bold* or new lines which we can use). Provide a settings UI for owners to opt in/out. Target to have at least weekly digests or immediate alerts for critical posts by the end of this phase.
> * **WhatsApp Q\&A Chatbot:** Build and deploy the Q\&A assistant. This will probably require setting up a separate service or function to handle the AI querying, as it might not fit directly in Next.js request/response due to potential long processing times. We might use a background function that the WhatsApp webhook triggers, which then responds via the API. Use the AI knowledge base prepared in Phase 2 (document text extraction) to answer questions. Start with a limited scope (e.g., documents from the last year, or specific categories) to evaluate accuracy. Expand as confidence grows. Also, implement fail-safes: if the AI is unsure or the confidence is low, have it respond with a helpful message like “I’m not certain about that. Please check the HOA portal for more details or contact the committee.” This prevents misinformation. Logging of Q\&A will be important here – possibly route unanswered questions to the committee so they can manually follow up or improve documentation.
> * **AI-driven Features in Portal:** Beyond WhatsApp, we can also integrate the Q\&A or summaries directly into the portal. For instance, a “Ask a question” text box on the dashboard could use the same backend to provide instant answers on the web (some owners might prefer that over WhatsApp). This isn’t strictly necessary but could be a nice addition. If time permits in this phase, implement a Q\&A modal on the site where owners can query the knowledge base.
> * **Open-Source Component Integration:** Evaluate remaining areas where open-source components could enhance the product. For example, if not yet implemented, use an open-source rich text editor for composing announcements (to allow formatting). Or integrate a library for file previews (images, PDFs) instead of custom coding. Ensure any library is compatible with our i18n (most UI libs are). Also consider security – any third-party component should be vetted for maintenance and licensing.
> * **Testing & Hardening:** By Phase 4, the platform will be feature-rich. Conduct extensive testing: simulate an entire user journey (from registration approval to reading docs to voting to asking a question on WhatsApp). Perform load testing on key functions (like many users downloading simultaneously, or the vector search for Q\&A under heavy queries). Improve any performance issues (maybe add caching for expensive operations like generating the weekly digest or AI answers). Also, gather feedback from actual users if possible during a pilot run and iterate on UX issues. The goal is to reach a stable, secure 1.0 release by the end of Phase 4.
>
> **Status:** Not started (planned). Phase 4 will likely run in parallel with late Phase 3 work, especially as the team working on AI might be different from the team doing polls. The timeline depends on external integration approvals (WhatsApp Business setup could take some time). This is the capstone phase to elevate the platform from a standard portal to an intelligent, connected system.

Finally, after these phases, the product should meet all initial requirements. Future improvements beyond Phase 4 could include things like a mobile app, integration with accounting systems for HOA fees, or a module for maintenance requests – but those are outside the current scope. For now, the roadmap above ensures that Costabeach will become a comprehensive HOA coordination platform, reflecting the existing implementation and delivering the remaining features in a structured way.

**Sources:** The above requirements and plans are based on the current codebase and configuration of the Costabeach project (GitHub repository) as well as the envisioned functionality needed for the HOA use case. Key implementation details have been derived from the repository’s code and documentation, ensuring that the PRD aligns with what’s already built and what is feasible to build next. All design/implementation suggestions (e.g., using PDF.js, using Twilio for WhatsApp, etc.) were made considering industry best practices and the specific context of this project.
